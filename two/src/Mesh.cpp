#include "Mesh.h"#include <iostream>#include <sstream>using namespace std;#define MAX_BUFFER 400void Mesh::load( const char* filename ){	// 2.1.1. load() should populate bindVertices, currentVertices, and faces	//typedef tuple< unsigned, 3 > Tuple3u;        //std::vector< Vector3f > bindVertices;        //std::vector< Tuple3u > faces;	// Add your code here.	Vector3f vert;	int a,b,c;  	string s; 	//initialize vectors for reading in verticies, faces, and normals 	//vector<Vector3f> vecv; 	//vector<Vector3f> vecn; 	//vector<int9> vecf; 	cout << "loading input" << endl; 	char buffer[MAX_BUFFER];	string buffer2; 	ifstream bob(filename);	if(!bob.is_open())    	{		cout << "file not open" <<endl;        	return;     	}		// load the OBJ file here	while(bob.getline(buffer,MAX_BUFFER))  //returns false when we are at end of file	{		stringstream ss(buffer); 		ss >> s;  		//case if vector type		if(s == "v")		{			ss >> vert[0] >> vert[1] >> vert[2];  			bindVertices.push_back(vert); 		}		if(s=="f")		{			ss >> a >> b >> c;  			//printFace(face); 			faces.push_back(Tuple3u(a,b,c));  //pushback joe and then pushback onto vecf 		}	}	//print out sizes of each of the lists we've read in	cout << "vertex, face " << bindVertices.size() << " " << faces.size() << endl; 	// make a copy of the bind vertices as the current vertices	currentVertices = bindVertices;}void Mesh::draw(){	Vector3f Normal; 		// Since these meshes don't have normals	// be sure to generate a normal per triangle.	// Notice that since we have per-triangle normals	// rather than the analytical normals from	// assignment 1, the appearance is "faceted".	glBegin(GL_TRIANGLES);	    	for (unsigned i=0; i<faces.size(); i++)    	{		Normal=Normal.cross(-currentVertices[faces[i][1]-1]+currentVertices[faces[i][2]-1],currentVertices[faces[i][0]-1]-currentVertices[faces[i][2]-1]);		Normal.normalize();         	glNormal(Normal);        	glVertex(currentVertices[faces[i][0]-1]);        	glNormal(Normal);        	glVertex(currentVertices[faces[i][1]-1]);		glNormal(Normal);        	glVertex(currentVertices[faces[i][2]-1]);    	}	glEnd();	/*	glBegin(GL_TRIANGLES);    	for (unsigned i=0; i<surface.VF.size(); i++)    	{        	glNormal(surface.VN[surface.VF[i][0]]);        	glVertex(surface.VV[surface.VF[i][0]]);        	glNormal(surface.VN[surface.VF[i][1]]);        	glVertex(surface.VV[surface.VF[i][1]]);        	glNormal(surface.VN[surface.VF[i][2]]);        	glVertex(surface.VV[surface.VF[i][2]]);   	 }    	glEnd();	*/}//std::vector< std::vector< float > > attachments;void Mesh::loadAttachments( const char* filename, int numJoints ){	//should be one less than total number of joints, doesn't include root	cout << "number of joints reading in " << numJoints <<endl; 	vector<float> guy; //I'm not your buddy, fwend 	float buddy; 		// 2.2. Implement this method to load the per-vertex attachment weights	// this method should update m_mesh.attachments		cout << "loading input" << endl; 	char buffer[MAX_BUFFER];	string buffer2; 	ifstream bob(filename);    	if(!bob.is_open())    	{		cout << "file not open" <<endl;        	return;     	}		// load the OBJ file here	int count=0; 	while(bob.getline(buffer,MAX_BUFFER))  //returns false when we are at end of file	{		stringstream ss(buffer);  		for(int n=0; n<(numJoints-1);n++)  //do not include root node, always has a weight of 0		{			ss >> buddy;			guy.push_back(buddy); 			if(count==3)			{				cout << buddy << " ";  //print out for debugging purposes  			}		}		attachments.push_back(guy);		guy.clear(); 			if(count==3)			cout << endl; 		count++;	}}